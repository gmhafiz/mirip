package template

import (
	"io"
	"strings"
	"text/template"

	"github.com/gmhafiz/mirip/internal/registry"
)

// Template is the Mirip template. It is capable of generating the Mirip
// implementation for the given template.Data.
type Template struct {
	tmpl *template.Template
}

// Execute generates and writes the Mirip implementation for the given
// data.
func (t Template) Execute(w io.Writer, data Data) error {
	return t.tmpl.Execute(w, data)
}

// New returns a new instance of Template.
func New() (Template, error) {
	tmpl, err := template.New("mirip").Funcs(templateFuncs).Parse(miripTemplate)
	if err != nil {
		return Template{}, err
	}

	return Template{tmpl: tmpl}, nil
}

// This list comes from the golint codebase. Golint will complain about any of
// these being mixed-case, like "Id" instead of "ID".
var golintInitialisms = []string{
	"ACL", "API", "ASCII", "CPU", "CSS", "DNS", "EOF", "GUID", "HTML", "HTTP", "HTTPS", "ID", "IP", "JSON", "LHS",
	"QPS", "RAM", "RHS", "RPC", "SLA", "SMTP", "SQL", "SSH", "TCP", "TLS", "TTL", "UDP", "UI", "UID", "UUID", "URI",
	"URL", "UTF8", "VM", "XML", "XMPP", "XSRF", "XSS",
}

var templateFuncs = template.FuncMap{
	"ImportStatement": func(imprt *registry.Package) string {
		if imprt.Alias == "" {
			return `"` + imprt.Path() + `"`
		}
		return imprt.Alias + ` "` + imprt.Path() + `"`
	},
	"SyncPkgQualifier": func(imports []*registry.Package) string {
		for _, imprt := range imports {
			if imprt.Path() == "sync" {
				return imprt.Qualifier()
			}
		}

		return "sync"
	},
	"Exported": func(s string) string {
		if s == "" {
			return ""
		}
		for _, initialism := range golintInitialisms {
			if strings.ToUpper(s) == initialism {
				return initialism
			}
		}
		return strings.ToUpper(s[0:1]) + s[1:]
	},
}

// miripTemplate is the template for mocked code.
// language=GoTemplate
var miripTemplate = `// Code generated by mirip; DO NOT EDIT.
// github.com/gmhafiz/mirip

package {{.PkgName}}

import (
{{- range .Imports}}
	{{. | ImportStatement}}
{{- end}}
)

{{range $i, $mock := .Mocks -}}

// {{.MockName}} is a mock implementation of {{$.SrcPkgQualifier}}{{.InterfaceName}}.
type {{.MockName}} struct {
{{- range .Methods}}
	{{.Name}}Func func({{.ArgList}}) {{.ReturnArgTypeList}}{{end}}
}

{{$out := .}}
{{- range .Methods}}
func (m * {{$out.MockName}} ) {{.Name}}({{.ArgList}}) {{.ReturnArgTypeList}} {
	return m.{{.Name}}Func({{.ArgCallList}})
}
{{end}}

{{end}}
`
